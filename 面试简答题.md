### 笔试-简述题



#### Java源码

- HashMap的原理以及其线程安全性？（极高）
- ArrayList？
- Object类中的方法（高）

#### JVM相关



- JVM的内存分配与管理，可能发生OutOfMemory的情况？
  1. JVM中内存区域的划分：Java堆（新生代（Eden、From Survivor、To Survivor）、老年代）、JVM栈、程序计数器、本地方法栈、方法区（永久代）
  2. 各个区域中存储的内容：
     - 堆（线程共享）：Java实例对象、数组
     - 方法区（线程共享）：JVM加载的类信息、常量、静态变量、JIT编译后的代码等
       - 运行时常量池：存放编译期生成的各种字面量和符号引用
     - 程序计数器：当前线程执行字节码的行号指示器
     - JVM栈：描述Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量表、操作数栈、***动态链接***、方法出口。每个方法从调用到执行完成的过程，对应着一个栈帧在JVM栈中入栈到出栈的过程。
     - 本地方法栈：与JVM栈类似，只不过执行的是Native方法。
  3. 各个区域可能抛出的异常：
     - JVM栈：线程请求的栈的深度大于JVM所允许的栈的深度，则抛出StackOverFlowError异常。例如：递归的深度太大。JVM栈是允许动态扩展的，如果在动态扩展时无法申请到足够的内存或者在创建一个线程时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
     - Java堆：堆中没有足够的空间完成实例的分配，并且无法扩展时，将会抛出OutOfMemoryError异常。
     - 方法区：方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
- JVM内存回收算法以及几种垃圾回收器的工作过程（极高）？
  1. 判断一个对象是否需要被回收：1. 引用计数算法（产生循环引用的问题） 2. 可达性分析算法	
     - 可达性分析算法：以GC Roots对象作为起点，当 一个对象到GC Roots对象没有任何引用链相连，则该对象不可用，需要被回收。可以作为GC Roots的对象：JVM栈的本地变量表中引用的对象、方法区中类的静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI引用的对象
     - 一个对象真正被回收之前至少经历两次标记过程。
  2. 垃圾回收算法：1. 标记-清除（产生内存碎片问题）、2. 复制（新生代中采用该算法，适用于对象存活率低的场景）、3. 标记-整理（将存货的对象移动到内存的一侧，然后清除边界外的内存）、4. 分代收集（新生代中使用复制算法、老年代中使用标记-清除或标记-整理）
  3. 常见的垃圾回收器
- Java对象在内存中的分配？
  1. 在Java中new一个对象的时候，首先判断该类的符号引用是否在常量池中。
  2. 判断该符号引用代表的类是否被加载、解析、初始化过；如果没有，则执行类的加载。
  3. 在对象的类被加载完成后，就可以确定一个对象所需内存的大小，所以这时在堆中为该对象划分内存空间。具体有两种方法：指针碰撞（堆中内存规整）、空闲列表（堆中内存不规整）。堆中内存是否规整由所采用的的垃圾回收器决定。
  4. 在分配内存时，可能存在多个线程同时需要分配内存。通常有两种方法：对分配空间的行为做同步处理（CAS方式）；TLAB（本地线程分配缓存），即在堆中为每个线程分配一小块空间，称为TLAB，首先在TLAB上分配内存，如果TLAB用完并分配新的TLAB时，才需要同步锁定。
  5. 内存空间分配完成后，将内存空间初始化为零值。（这就是Java对象的实例属性不需要初始化就可以使用的原因）注：局部变量需要初始化，否则会编译报错。
  6. 设置对象头（Object Header），包括所属类信息、如何找到类的元数据、对象Hash码、GC分代年龄等。
  7. 至此对于JVM而言创建对象已经完成，但是对于Java程序来说，还需要对该对象进行初始化。
     - 对象的内存布局：
       - 对象头：自身运行时数据（HashCode、GC分代年龄、锁状态标志）、类型指针（指向类元数据的指针）、对于Java数组对象还存储着数组的长度信息。
       - 实例数据：存储类中定义的数据（包括从父类继承的），相同长度的数据总是被分配在一起。
       - 对齐填充：JVM要求对象的起始地址必须是8的整倍数。对象头一定是8的整倍数，但是实例数据则不一定满足，所以需要对齐填充。
  8. 总结：判断类是否被JVM加载 --> 在堆中分配内存空间 --> 内存空间初始化 --> 设置对象的对象头 --> 初始化对象。
- JVM常用的配置参数？
  - -Xms20m：指定堆的最小内存为20M
  - -Xmx20M：指定堆的最大内存为20M
  - -XX:+HeapDumpOnOutOfMemoryError：使JVM在发生内存溢出时Dump出当前内存堆转储快照
  - -Xss：设置JVM栈内存容量
  - -XX:PermSize：设置方法区容量
  - -XX:MaxPermSize：设置方法区最大容量
  - -XX:MaxDirectMemorySize：设置直接内存容量


#### Java多线程相关

- 线程的几种状态：新建、可运行、运行、阻塞、死亡


- Lock和synchronized的区别，以及如何选择？
- volatile和synchronized关键字？（高）
- 线程池（高）
- 内存屏障




#### MySQL相关

- 数据库的几种索引？（极高）
- 数据库的事务？
- MySQL存储引擎？（极高）
- 隔离级别


#### Redis相关

- Redis支持的数据类型：string、list、set、sorted set、hash

- Redis是单进程单线程的，内部使用队列技术将并发访问变为串行访问，达到异步非阻塞的效果。

  ![](D:\ProgramLearning\笔记\笔试面试\assets\9ea86eb5-000a-4281-b948-7b567bd6f1d8.png)

- Redis备份数据的两种方式：RDB持久化（将内存中的所有数据保存在磁盘中）、AOF持久化（将写命令保存在AOF文件的末尾）。

- Redis中过期的key是如何删除的？

  - 定期删除：Redis每个一定时间，检查设置了过期时间的key，从中选取一部分删除。
  - 惰性删除：在访问一个key之间，先判断是否设置了过期时间，在判断是否过期，如果过期则删除并返回nil。

- Redis的内存是有限的，当内存占用过多时，会进行内存淘汰。主要有以下几种淘汰策略：

  1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了

  2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）

  3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊

  4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）

  5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key

  6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除




#### 设计模式（极高）

- 单例、工厂、抽象工厂（极高）





#### Spring相关

- Spring IOC、AOP的理解


- Spring中Autowire和Resource的区别？
- Spring常用注解

#### 算法

- 堆排序、快速排序
- 二叉树
- 链表
- 红黑树（较高）
- 动态规划

#### 其他

- 常用的加密、解密算法
- 高并发、高负载、高可用、高性能
- Forward和Redirect的区别
- 消息队列
- 分布式（高）
- Tomcat
- Session一致性
- Java Socket编程
- BIO、NIO、AIO
- Linux常用命令
- HTTP请求的过程
- 负载均衡