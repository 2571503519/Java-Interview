### 数据库

- 什么是存储过程？

  存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。

  优点:

  - 存储过程是一个预编译的代码块，因此执行效率比较高
  - 一个存储过程代替了大量的T_SQL语句，降低网络通信量
  - 一定程度上确保数据安全

- 主键生成策略

- 数据库中的索引

  索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构。

  - MySQL数据库中基本的索引类型：普通索引、唯一索引、主键索引、全文索引
    - 普通索引：最基本的索引，没有任何限制
    - 唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。
    - 主键索引：它 是一种特殊的唯一索引，不允许有空值。 
    - 全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。
    - 组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。
  - 索引的作用：
    - 加快数据库检索数据的速率
    - 唯一索引确保了数据的唯一性
    - 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
    - 降低了插入、删除、修改等维护任务的速度（因为大部分数据更新需要同时更新索引）
    - 索引需要占用物理和数据空间
  - 索引失效的原因：
    - 使用不等于（！= 或者<>）不能使用索引
    - 使用 is null 或者 is not null 也不能使用索引
    - like 已通配符开头（%abc）导致索引失效
    - 少用or，用它来连接索引会失效（使用 union all 代替 ）
    - in 和 not in 也要慎用，否则会导致全表扫描（连续的数值使用between）
    - 尽量使用覆盖索引减少使用select *
    - 不要在索引列上做任何操作
    - 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致
    - 尽量使用数字型字段

- 数据一致性

  	在数据有多分副本的情况下，如果网络、服务器或者软件出现故障，会导致部分副本写入成功，部分副本写入失败。这就造成各个副本之间的数据不一致，数据内容冲突。 实践中，导致数据不一致的情况有很多种，表现样式也多种多样，比如数据更新返回操作失败，事实上数据在存储服务器已经更新成功。

- MySQL中的连接（Join)分为内链接、左外连接、右外连接（INNER JOIN、LEFT JOIN、RIGHT JOIN）; 

  - 内链接：取两个表的交集，仅显示符合连接条件的记录； 
  - 左外连接：显示左表的全部记录及右表符合连接条件的记录； 
  - 右外连接：显示右表的全部记录及左表符合连接条件的记录。

- 事务和分布式事务

  - 事务

    事务（Transaction）是**并发控制的基本单位**。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。

    - 事务的四个基本特征

      - Atomic（原子性）：一个事务中的所有操作要么全部成功，要么全部失败。
      - Consistency（一致性）：事务遵循数据完整性约束，即只有合法的数据才被写入。
      - Isolation（隔离性）：多个事务之间的隔离程度。
      - Durablity（持久性）：事务结束后，事务对数据库的修改都会被保存在数据库中。

    - 隔离级别：

      - 读未提交（脏读问题）：允许一个事务读取另一事务未提交的数据
      - 读/写提交（克服脏读，产生不可重复读问题）：一个事务只能读取到另一事务已经提交的数据
      - 可重复读（MySQL默认隔离级别）（产生幻读问题）：可重复读使同一条数据库记录的读/写按照一个序列化进行操作
      - 序列化（克服幻读问题）：使SQL按照顺序读/写

    - 事务基本语句

      ```sql
      set autocommit=0; // 关闭自动提交事务
      Begin Transaction; // 开启事务
      Commit Transaction; // 提交事务
      Rollback Transaction; // 回滚事务
      Save Transaction 保存点名称; // 自定义保存点的名称和位置
      Rollback Transaction 保存点名称; // 回滚事务到指定保存点
      ```

- 悲观锁和乐观锁

  - 悲观锁：正如其名，它指的是对数据被外界修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）

    - 悲观锁流程：

    1. 在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。
    2. 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
    3. 如果成功加锁，那么就可以对记录做修改，操作完成后就会解锁了。
    4. 期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

    - 注意：使用 select…for update 会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。

  - 乐观锁：相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回错误的信息，让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本（版本号、时间戳）。

    - 不足：两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

- MySQL中的两种存储引擎

  - InnoDB（默认存储引擎，支持事务）：

    表是基于聚簇索引建立的，它对主键的查询性能有很高的提升。

    内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够自动在内存中创建哈希索引以加速读操作的自适应哈希索引、能够加速插入操作的插入缓冲区等。

    通过一些机制和工具支持真正的热备份，其它存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

  - MyISAM（不支持事务，不支持行级锁，只能对整张表加锁）：

    MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以继续使用 MyISAM。

  - 二者比较：

    1. 事务：InnoDB 是事务型的。
    2. 备份：InnoDB 支持在线热备份。
    3. 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
    4. 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
    5. 其它特性：MyISAM 支持压缩表和空间数据索引。

- MySQL中数据的数据类型：

  - 整形：tinyint、smallint、mediumint、int、bigint分别占用存储空间1、2、3、4、8个字节
  - 浮点数：float、double，分别占用4、8字节;decimal为高精度小数，存储时超出了整数部分超出范围会报错，小数部分四舍五入后使整数超出范围也会报错。格式为decimal(10, 2)，表示整数加小数位数总共10位，小数部分位数为2位（默认情况下为decimal (10,0) ）
  - 字符串：char（定长）、varchar（不定长），定长不定长是指在存储的时候根据实际内容的长度确定存储空间。例如：char(4) 就表示最多能存4个字节不足4个字节按照4个字节存储（不保留末尾空格）；varchar(10)表示最多存10个字节，实际字符多长就占多少空间（保留末尾空格）
  - 日期和时间：datetime、timestamp（推荐使用）分别占用8、4字节；

- SQL（常用的不介绍）：

  - 插入：

    - 插入检索出来的数据：

      ```sql
      INSERT INTO mytable1(col1, col2)
      SELECT col1, col2 FROM mytable2;
      ```

    - 将一个表中的内容插入到一个新表

      ```sql
      CREATE TABLE tablename AS 
      SELECT col1，col2 FROM oldtable；
      ```

  - 删除：

    - 清空表中数据

      ```sql
      TRUNCATE tablenam；
      ```

    - 删除表

      ```sql
      DROP TABLE tablename；
      ```

  - 查询：

    - 相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。

      ```sql
      SELECT DISTINCT col1, col2
      FROM mytable;
      ```

    - 过滤条件：使用where语句对数据进行过滤，其中过滤条件：

      | =   >    <            | 等于 大于 小于         |
      | --------------------- | ---------------------- |
      | != <>                 | 不等于                 |
      | <=    >=              | 小于等于  大于等于     |
      | BETWEEN num1 AND num2 | 在两个值之间(左闭右开) |
      | IS NULL               | 为空                   |

      注： NOT 表示取反，IN（val1, val2, val3）表示在一组集合中

    - 通配符：

      通配符也是用在过滤语句中，但它只能用于文本字段。

      - **%**  匹配 >=0 个任意字符；
      - **\_**  匹配 ==1 个任意字符；
      - **[ ]**  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。

      使用 Like 来进行通配符匹配。

      ```sql
      SELECT *
      FROM mytable
      WHERE col LIKE '[^AB]%' -- 不以 A 和 B 开头的任意文本
      ```

      注： 不要滥用通配符，通配符位于开头处匹配会非常慢。

    - 分组：Where 过滤行 ，Having过滤分组，并且应该先过滤行在过滤分组

      ```sql
      select vend_id, count(*), min(prod_price) as min_price // 起别名
      from products 
      group by vend_id  // 以vend_id为分组依据
      having min_price > 5 // 过滤min_price不符合条件的分组
      ORDER BY min_price; // 将分组的结果按照指定列排序
      ```

    - 连接查询：内连接，外连接，左外连接，右外连接

    - 组合查询

      使用  **UNION**  来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。

      每个查询必须包含相同的列、表达式和聚集函数。

      默认会去除相同行，如果需要保留相同行，使用 UNION ALL。

      只能包含一个 ORDER BY 子句，并且必须位于语句的最后。

      ```sql
      SELECT col
      FROM mytable
      WHERE col = 1
      UNION
      SELECT col
      FROM mytable
      WHERE col =2;
      ```

      ​

- 热备份和冷备份：https://blog.csdn.net/teslafzy/article/details/61200110

- 视图：视图是虚表，是从一个或几个基本表（或视图）中导出的表，在系统的[数据字典](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8)中仅存放了视图的定义，不存放视图对应的数据。由于逻辑上的原因，有些视图可以修改对应的基表，而有些则不能（仅仅能查询）

- 数据库三个范式

  - 第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。
  - 第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。
  - 第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y



### 相关题目

1. 下列关于视图的说法中正确的是（  ）  

      A.  对视图的使用与表一样，也可以进行插、查、删、改操作  

      B.  视图与表一样，也存储着数据  

      C.  对视图的操作，是最终都要转化成对基本表的操作  

      D.  可以根据数据库表和自由表建立视图  

      参考答案：C、D

2. 对于索引的理解与运用，以下说法正确的是（ B  ）
   A. 只能对单独一列建立索引
   B. CREATE INDEX idx_acct_flow_bu ON BILL_ID(BILL)这是在为BILL表的BILL_ID字段建立索引
   C. 索引能提高查询效率，所以创建表的时候需要将所有列都加上索引
   D. 以上说法都对

3. 已知表T，字段为索引字段，F可以为任意数据类型，下列sql中索引未起作用的语句是（B）  

   A select  *from T where T,F <1000*

   B select*  from T where T,F like ‘%cool’

   C select  from T where T,F in (1,2,3) 

   D select  from T where T,F =’book’

   原因分析：like的模糊查询以 % 开头，索引失效；

4. 如下哪些sql语句查询能较好的利用字段a索引（  **AD**  ）？ 

     A.  Select a from Table where a like ‘aaa%’ 

     B.  Select a,b,c from Table where a=’学生’ orderby  b,c 

     C.  Select a from Table where a is not null 

     D.  Select a,b,c from Table where a=’学生’ orderby a

5. 在数据库中，产生数据不一致的根本原因是什么( D )

   A 数据存储量太大

   B 没有严格保护数据

   C 未对数据进行完整性控制

   D 数据冗余

6. 在关系型数据库中，适合建立索引的字段有（ ）
   A. 主键字段
   B. 在WHERE句中的字段
   C. 外键字段
   D. 在SELECT句中的字段

   **参考答案：A、B、C**

